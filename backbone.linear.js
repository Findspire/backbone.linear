// Generated by CoffeeScript 1.7.1
(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  (function(global, _, Backbone, factory) {
    if (typeof define === "function" && define.amd) {
      return define(["underscore", "backbone"], function(_, Backbone) {
        return global.Backbone.Linear_Model = factory(_, Backbone);
      });
    } else if (typeof module !== "undefined" && module.exports) {
      _ = require("undescore");
      Backbone = require("backbone");
      return module.exports = factory(_, Backbone);
    } else {
      return global.Backbone.Linear_Model = factory(_, Backbone);
    }
  })(this, _, Backbone, function(_, Backbone) {
    return Backbone.Linear_Model = (function(_super) {
      var flatten, unflatten;

      __extends(Linear_Model, _super);

      function Linear_Model() {
        return Linear_Model.__super__.constructor.apply(this, arguments);
      }

      flatten = function(target, opts) {
        var delimiter, output, step;
        delimiter = opts.delimiter || ".";
        output = {};
        step = function(object, prev) {
          return Object.keys(object).forEach(function(key) {
            var isarray, isobject, newKey, type, value;
            value = object[key];
            isarray = opts.safe && Array.isArray(value);
            type = Object.prototype.toString.call(value);
            isobject = type === "[object Object]" || type === "[object Array]";
            newKey = prev ? prev + delimiter + key : key;
            if (!isarray && isobject) {
              return step(value, newKey);
            }
            return output[newKey] = value;
          });
        };
        step(target);
        return output;
      };

      unflatten = function(target, opts) {
        var delimiter, getkey, result;
        delimiter = opts.delimiter || ".";
        result = {};
        if (Object.prototype.toString.call(target) !== "[object Object]") {
          return target;
        }
        getkey = function(key) {
          var parsedKey;
          parsedKey = Number(key);
          if (isNaN(parsedKey) || key.indexOf(".") !== -1) {
            return key;
          } else {
            return parsedKey;
          }
        };
        return Object.keys(target).forEach(function(key) {
          var key1, key2, recipient, split;
          split = key.split(delimiter);
          key1 = getkey(split.shift());
          key2 = getkey(split[0]);
          recipient = result;
          while (key2 !== void 0) {
            if (recipient[key1] === void 0) {
              recipient[key1] = typeof key2 === "number" && (!opts.object ? [] : {});
            }
            recipient = recipient[key1];
            if (split.length > 0) {
              key1 = getkey(split.shift());
              key2 = getkey(split[0]);
            }
            recipient[key1] = unflatten(target[key], opts);
          }
          return result;
        });
      };

      Linear_Model.prototype.parse = function() {
        return flatten(Linear_Model.__super__.parse.apply(this, arguments), this.flat_options);
      };

      Linear_Model.prototype.sync = function(method, model, options) {
        var attrs, opts;
        attrs = unflatten(options.attrs || model.toJSON(options), this.flat_options);
        opts = _.extend(options, {
          attrs: attrs
        });
        return Linear_Model.__super__.sync.call(this, method, model, opts);
      };

      Linear_Model.prototype.flat_options = {};

      return Linear_Model;

    })(Backbone.Model);
  });

}).call(this);
