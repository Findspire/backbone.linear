(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  (function(global, factory) {
    var Backbone, _;
    if (typeof define === "function" && define.amd) {
      return define(["underscore", "backbone"], function(_, Backbone) {
        return global.Backbone.Linear_Model = factory(_, Backbone);
      });
    } else if (typeof module !== "undefined" && module.exports) {
      _ = require("underscore");
      Backbone = require("backbone");
      return module.exports = factory(_, Backbone);
    } else {
      return global.Backbone.Linear_Model = factory(global._, global.Backbone);
    }
  })(this, function(_, Backbone) {
    return Backbone.Linear_Model = (function(_super) {
      var flatten, unflatten, _transform_to_array;

      __extends(Linear_Model, _super);

      function Linear_Model() {
        return Linear_Model.__super__.constructor.apply(this, arguments);
      }

      Linear_Model.flatten = flatten = function(target, opts) {
        var delimiter, output, step;
        if (opts == null) {
          opts = {};
        }
        delimiter = opts.delimiter || ".";
        output = {};
        step = function(object, prev) {
          return Object.keys(object).forEach(function(key) {
            var isarray, isobject, newKey, type, value;
            value = object[key];
            isarray = opts.safe && Array.isArray(value);
            type = Object.prototype.toString.call(value);
            isobject = type === "[object Object]" || type === "[object Array]";
            newKey = prev ? prev + delimiter + key : key;
            if (!isarray && isobject) {
              return step(value, newKey);
            }
            return output[newKey] = value;
          });
        };
        step(target);
        return output;
      };

      Linear_Model.unflatten = unflatten = function(target, opts) {
        var delimiter, getkey, result;
        if (opts == null) {
          opts = {};
        }
        delimiter = opts.delimiter || ".";
        result = {};
        if (Object.prototype.toString.call(target) !== "[object Object]") {
          return target;
        }
        getkey = function(key) {
          var parsedKey;
          parsedKey = Number(key);
          if (isNaN(parsedKey) || key.indexOf(".") !== -1) {
            return key;
          } else {
            return parsedKey;
          }
        };
        Object.keys(target).forEach(function(key) {
          var key1, key2, recipient, split;
          split = key.split(delimiter);
          key1 = getkey(split.shift());
          key2 = getkey(split[0]);
          recipient = result;
          while (key2 !== void 0) {
            if (recipient[key1] === void 0) {
              recipient[key1] = typeof key2 === "number" && !opts.object ? [] : {};
            }
            recipient = recipient[key1];
            if (split.length > 0) {
              key1 = getkey(split.shift());
              key2 = getkey(split[0]);
            }
          }
          return recipient[key1] = unflatten(target[key], opts);
        });
        return result;
      };

      Linear_Model.prototype.parse = function() {
        var flat_options, has_force_array, parent_call, result;
        parent_call = Linear_Model.__super__.parse.apply(this, arguments);
        if ((parent_call == null) || parent_call === "" || parent_call instanceof this.constructor) {
          return parent_call;
        }
        flat_options = _.clone(this.flat_options);
        if ((has_force_array = _.isArray(flat_options.force_array))) {
          flat_options.safe = true;
        }
        result = flatten(parent_call, flat_options);
        if (has_force_array) {
          return _transform_to_array(result, flat_options.force_array);
        } else {
          return result;
        }
      };

      Linear_Model.prototype.sync = function(method, model, options) {
        var opts;
        if (options == null) {
          options = {};
        }
        switch (method) {
          case "create":
          case "update":
          case "patch":
            opts = _.extend({}, options, method === "patch" ? {
              attrs: unflatten(options.attrs, this.flat_options)
            } : {
              unflat: true
            });
            return Linear_Model.__super__.sync.call(this, method, model, opts);
          default:
            return Linear_Model.__super__.sync.apply(this, arguments);
        }
      };

      Linear_Model.prototype.toJSON = function(options) {
        if (options == null) {
          options = {};
        }
        if (options.unflat) {
          return unflatten(Linear_Model.__super__.toJSON.apply(this, arguments), this.flat_options);
        } else {
          return Linear_Model.__super__.toJSON.apply(this, arguments);
        }
      };

      _transform_to_array = function(object, force_array) {
        var obj_in_path, path, _i, _len;
        for (_i = 0, _len = force_array.length; _i < _len; _i++) {
          path = force_array[_i];
          if (_.isArray(object[path])) {
            continue;
          } else if (object[path] != null) {
            object[path] = [object[path]];
          } else {
            obj_in_path = {};
            object = _(object).pairs().map(function(arr) {
              var key, val;
              key = arr[0], val = arr[1];
              if (key.match(RegExp("^" + path))) {
                obj_in_path["" + (path.match(/\.(\w+)$/)[1])] = val;
                return null;
              } else {
                return [key, val];
              }
            }).compact().object().value();
            object[path] = _.size(obj_in_path) ? [obj_in_path] : [];
          }
        }
        return object;
      };

      Linear_Model.prototype.flat_options = {};

      return Linear_Model;

    })(Backbone.Model);
  });

}).call(this);

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFja2JvbmUubGluZWFyLmpzIiwic291cmNlcyI6WyJiYWNrYm9uZS5saW5lYXIuY29mZmVlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUEsTUFBQTttU0FBQTs7QUFBQSxFQUFHLENBQUEsU0FDQyxNQURELEVBRUMsT0FGRCxHQUFBO0FBdUtDLFFBQUEsV0FBQTtBQUFBLElBQUEsSUFBRyxNQUFBLENBQUEsTUFBQSxLQUFpQixVQUFqQixJQUFrQyxNQUFNLENBQUMsR0FBNUM7YUFDSSxNQUFBLENBQU8sQ0FBQyxZQUFELEVBQWUsVUFBZixDQUFQLEVBQW1DLFNBQUMsQ0FBRCxFQUFJLFFBQUosR0FBQTtlQUMvQixNQUFNLENBQUMsUUFBUSxDQUFDLFlBQWhCLEdBQStCLE9BQUEsQ0FBUSxDQUFSLEVBQVcsUUFBWCxFQURBO01BQUEsQ0FBbkMsRUFESjtLQUFBLE1BSUssSUFBRyxNQUFBLENBQUEsTUFBQSxLQUFtQixXQUFuQixJQUFxQyxNQUFNLENBQUMsT0FBL0M7QUFDRCxNQUFBLENBQUEsR0FBSSxPQUFBLENBQVEsWUFBUixDQUFKLENBQUE7QUFBQSxNQUNBLFFBQUEsR0FBVyxPQUFBLENBQVEsVUFBUixDQURYLENBQUE7YUFFQSxNQUFNLENBQUMsT0FBUCxHQUFpQixPQUFBLENBQVEsQ0FBUixFQUFXLFFBQVgsRUFIaEI7S0FBQSxNQUFBO2FBTUQsTUFBTSxDQUFDLFFBQVEsQ0FBQyxZQUFoQixHQUErQixPQUFBLENBQVEsTUFBTSxDQUFDLENBQWYsRUFBa0IsTUFBTSxDQUFDLFFBQXpCLEVBTjlCO0tBM0tOO0VBQUEsQ0FBQSxDQUFILENBQ2EsSUFEYixFQUVjLFNBQUMsQ0FBRCxFQUFJLFFBQUosR0FBQTtXQUVBLFFBQVEsQ0FBQztBQUtYLFVBQUEsdUNBQUE7O0FBQUEscUNBQUEsQ0FBQTs7OztPQUFBOztBQUFBLE1BQUEsWUFBQyxDQUFBLE9BQUQsR0FBVyxPQUFBLEdBQVUsU0FBQyxNQUFELEVBQVMsSUFBVCxHQUFBO0FBQ2pCLFlB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TyxDQUFBLElBQUEsQ0FBUixDQUFmLENBREM7V0FBQSxNQUFBO0FBR0QsWUFBQSxXQUFBLEdBQWMsRUFBZCxDQUFBO0FBQUEsWUFDQSxNQUFBLEdBQ0ksQ0FBQSxDQUFFLE1BQUYsQ0FDQSxDQUFDLEtBREQsQ0FBQSxDQUVBLENBQUMsR0FGRCxDQUVLLFNBQUMsR0FBRCxHQUFBO0FBQ0Qsa0JBQUEsUUFBQTtBQUFBLGNBQUMsWUFBRCxFQUFNLFlBQU4sQ0FBQTtBQUNBLGNBQUEsSUFBRyxHQUFHLENBQUMsS0FBSixDQUFVLE1BQUEsQ0FBUSxHQUFBLEdBQXBELElBQTRDLENBQVYsQ0FBSDtBQUNJLGdCQUFBLFdBQVksQ0FBQSxFQUFBLEdBQUUsQ0FDVixJQUFJLENBQUMsS0FBTCxDQUFXLFVBQVgsQ0FBdUIsQ0FBQSxDQUFBLENBRGIsQ0FBRixDQUFaLEdBRU0sR0FGTixDQUFBO3VCQUdBLEtBSko7ZUFBQSxNQUFBO3VCQU1JLENBQUMsR0FBRCxFQUFNLEdBQU4sRUFOSjtlQUZDO1lBQUEsQ0FGTCxDQVdBLENBQUMsT0FYRCxDQUFBLENBWUEsQ0FBQyxNQVpELENBQUEsQ0FhQSxDQUFDLEtBYkQsQ0FBQSxDQUZKLENBQUE7QUFBQSxZQWdCQSxNQUFPLENBQUEsSUFBQSxDQUFQLEdBQ08sQ0FBQyxDQUFDLElBQUYsQ0FBTyxXQUFQLENBQUgsR0FDSSxDQUFDLFdBQUQsQ0FESixHQUdJLEVBcEJSLENBSEM7V0FIVDtBQUFBLFNBQUE7ZUEyQkEsT0E1QmtCO01BQUEsQ0F4SHRCLENBQUE7O0FBQUEsNkJBMEpBLFlBQUEsR0FBZSxFQTFKZixDQUFBOzswQkFBQTs7T0FMZ0MsUUFBUSxDQUFDLE9BRnZDO0VBQUEsQ0FGZCxDQUFBLENBQUE7QUFBQSIsInNvdXJjZXNDb250ZW50IjpbImRvIChcbiAgICBnbG9iYWwgPSBAXG4gICAgZmFjdG9yeSA9IChfLCBCYWNrYm9uZSktPlxuXG4gICAgICAgIGNsYXNzIEJhY2tib25lLkxpbmVhcl9Nb2RlbCBleHRlbmRzIEJhY2tib25lLk1vZGVsXG5cbiAgICAgICAgICAgICMgKioqKioqKioqKioqKioqKlxuICAgICAgICAgICAgIyAgICBGTEFUIDEuMi4xXG4gICAgICAgICAgICAjICoqKioqKioqKioqKioqKipcbiAgICAgICAgICAgIEBmbGF0dGVuID0gZmxhdHRlbiA9ICh0YXJnZXQsIG9wdHMgPSB7fSktPlxuICAgICAgICAgICAgICAgIGRlbGltaXRlciA9IG9wdHMuZGVsaW1pdGVyICBvciAgXCIuXCJcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSB7fVxuXG4gICAgICAgICAgICAgICAgc3RlcCA9IChvYmplY3QsIHByZXYpLT5cbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmtleXMgb2JqZWN0XG4gICAgICAgICAgICAgICAgICAgIC5mb3JFYWNoIChrZXkpLT5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gb2JqZWN0W2tleV1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlzYXJyYXkgPSBvcHRzLnNhZmUgIGFuZCAgQXJyYXkuaXNBcnJheSB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSA9IE9iamVjdDo6dG9TdHJpbmcuY2FsbCB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgaXNvYmplY3QgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgaXMgXCJbb2JqZWN0IE9iamVjdF1cIiAgb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlIGlzIFwiW29iamVjdCBBcnJheV1cIlxuXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdLZXkgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIHByZXZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldiArIGRlbGltaXRlciArIGtleVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIG5vdCBpc2FycmF5ICBhbmQgIGlzb2JqZWN0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0ZXAgdmFsdWUsIG5ld0tleVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRbbmV3S2V5XSA9IHZhbHVlXG5cbiAgICAgICAgICAgICAgICBzdGVwIHRhcmdldFxuICAgICAgICAgICAgICAgIG91dHB1dFxuXG4gICAgICAgICAgICBAdW5mbGF0dGVuID0gdW5mbGF0dGVuID0gKHRhcmdldCwgb3B0cyA9IHt9KS0+XG4gICAgICAgICAgICAgICAgZGVsaW1pdGVyID0gb3B0cy5kZWxpbWl0ZXIgIG9yICBcIi5cIlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHt9XG5cbiAgICAgICAgICAgICAgICBpZiBPYmplY3Q6OnRvU3RyaW5nLmNhbGwodGFyZ2V0KSBpc250IFwiW29iamVjdCBPYmplY3RdXCJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldFxuXG4gICAgICAgICAgICAgICAgIyBzYWZlbHkgZW5zdXJlIHRoYXQgdGhlIGtleSBpc1xuICAgICAgICAgICAgICAgICMgYW4gaW50ZWdlci5cbiAgICAgICAgICAgICAgICBnZXRrZXkgPSAoa2V5KS0+XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZEtleSA9IE51bWJlcihrZXkpXG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNOYU4ocGFyc2VkS2V5KSAgb3JcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleS5pbmRleE9mKFwiLlwiKSBpc250IC0xXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleVxuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZWRLZXlcblxuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzIHRhcmdldFxuICAgICAgICAgICAgICAgIC5mb3JFYWNoIChrZXkpLT5cbiAgICAgICAgICAgICAgICAgICAgc3BsaXQgPSBrZXkuc3BsaXQgZGVsaW1pdGVyXG4gICAgICAgICAgICAgICAgICAgIGtleTEgPSBnZXRrZXkgc3BsaXQuc2hpZnQoKVxuICAgICAgICAgICAgICAgICAgICBrZXkyID0gZ2V0a2V5IHNwbGl0WzBdXG4gICAgICAgICAgICAgICAgICAgIHJlY2lwaWVudCA9IHJlc3VsdFxuXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIGtleTIgaXNudCB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIHJlY2lwaWVudFtrZXkxXSBpcyB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWNpcGllbnRba2V5MV0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiB0eXBlb2Yga2V5MiBpcyBcIm51bWJlclwiICBhbmQgIG5vdCBvcHRzLm9iamVjdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW11cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge31cblxuICAgICAgICAgICAgICAgICAgICAgICAgcmVjaXBpZW50ID0gcmVjaXBpZW50W2tleTFdXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiBzcGxpdC5sZW5ndGggPiAwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5MSA9IGdldGtleSBzcGxpdC5zaGlmdCgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5MiA9IGdldGtleSBzcGxpdFswXVxuXG4gICAgICAgICAgICAgICAgICAgICMgdW5mbGF0dGVuIGFnYWluIGZvciAnbWVzc3kgb2JqZWN0cydcbiAgICAgICAgICAgICAgICAgICAgcmVjaXBpZW50W2tleTFdID0gdW5mbGF0dGVuIHRhcmdldFtrZXldLCBvcHRzXG5cbiAgICAgICAgICAgICAgICByZXN1bHRcblxuXG4gICAgICAgICAgICAjICoqKioqKioqKioqKioqKioqKioqXG4gICAgICAgICAgICAjICAgIEJBQ0tCT05FIDEuMS4yXG4gICAgICAgICAgICAjICoqKioqKioqKioqKioqKioqKioqXG4gICAgICAgICAgICBwYXJzZSA6IC0+XG4gICAgICAgICAgICAgICAgcGFyZW50X2NhbGwgPSBzdXBlclxuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgbm90IHBhcmVudF9jYWxsPyAgb3JcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50X2NhbGwgaXMgXCJcIiAgb3JcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50X2NhbGwgaW5zdGFuY2VvZiBAY29uc3RydWN0b3JcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJlbnRfY2FsbFxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGZsYXRfb3B0aW9ucyA9IF8uY2xvbmUgQGZsYXRfb3B0aW9uc1xuICAgICAgICAgICAgICAgIGlmICggaGFzX2ZvcmNlX2FycmF5ID0gXy5pc0FycmF5IGZsYXRfb3B0aW9ucy5mb3JjZV9hcnJheSApXG4gICAgICAgICAgICAgICAgICAgIGZsYXRfb3B0aW9ucy5zYWZlID0gdHJ1ZVxuXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZmxhdHRlbiBwYXJlbnRfY2FsbCwgZmxhdF9vcHRpb25zXG5cbiAgICAgICAgICAgICAgICBpZiBoYXNfZm9yY2VfYXJyYXlcbiAgICAgICAgICAgICAgICAgICAgX3RyYW5zZm9ybV90b19hcnJheSByZXN1bHQsIGZsYXRfb3B0aW9ucy5mb3JjZV9hcnJheVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0XG5cbiAgICAgICAgICAgIHN5bmMgOiAobWV0aG9kLCBtb2RlbCwgb3B0aW9ucyA9IHt9KS0+XG4gICAgICAgICAgICAgICAgc3dpdGNoIG1ldGhvZFxuICAgICAgICAgICAgICAgICAgICB3aGVuIFwiY3JlYXRlXCIsIFwidXBkYXRlXCIsIFwicGF0Y2hcIlxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0cyA9IF8uZXh0ZW5kIHt9LCBvcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIG1ldGhvZCBpcyBcInBhdGNoXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cnMgOiB1bmZsYXR0ZW4gb3B0aW9ucy5hdHRycywgQGZsYXRfb3B0aW9uc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5mbGF0IDogdHJ1ZVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBzdXBlciBtZXRob2QsIG1vZGVsLCBvcHRzXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1cGVyXG5cbiAgICAgICAgICAgIHRvSlNPTiA6IChvcHRpb25zID0ge30pLT5cbiAgICAgICAgICAgICAgICBpZiBvcHRpb25zLnVuZmxhdFxuICAgICAgICAgICAgICAgICAgICB1bmZsYXR0ZW4gc3VwZXIsIEBmbGF0X29wdGlvbnNcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHN1cGVyXG5cblxuICAgICAgICAgICAgIyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICAgICAgIyAgICBCQUNLQk9ORS1MSU5FQVItUFJJVkFURVxuICAgICAgICAgICAgIyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICAgICAgX3RyYW5zZm9ybV90b19hcnJheSA9IChvYmplY3QsIGZvcmNlX2FycmF5KS0+XG4gICAgICAgICAgICAgICAgZm9yIHBhdGggaW4gZm9yY2VfYXJyYXlcbiAgICAgICAgICAgICAgICAgICAgaWYgXy5pc0FycmF5IG9iamVjdFtwYXRoXVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiBvYmplY3RbcGF0aF0/XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmplY3RbcGF0aF0gPSBbb2JqZWN0W3BhdGhdXVxuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBvYmpfaW5fcGF0aCA9IHt9XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmplY3QgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF8gb2JqZWN0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnBhaXJzKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAubWFwIChhcnIpLT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW2tleSwgdmFsXSA9IGFyclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiBrZXkubWF0Y2ggUmVnRXhwIFwiXiN7IHBhdGggfVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmpfaW5fcGF0aFtcIiN7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aC5tYXRjaCgvXFwuKFxcdyspJC8pWzFdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XCJdID0gdmFsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtrZXksIHZhbF1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY29tcGFjdCgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLm9iamVjdCgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnZhbHVlKClcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdFtwYXRoXSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgXy5zaXplIG9ial9pbl9wYXRoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtvYmpfaW5fcGF0aF1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtdXG4gICAgICAgICAgICAgICAgb2JqZWN0XG5cblxuICAgICAgICAgICAgIyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICAgICAgICAjICAgIEJBQ0tCT05FLUxJTkVBUi1QVUJMSUNcbiAgICAgICAgICAgICMgKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICAgICAgZmxhdF9vcHRpb25zIDoge31cblxuKSAtPlxuICAgIFxuICAgIGlmIHR5cGVvZiBkZWZpbmUgaXMgXCJmdW5jdGlvblwiICBhbmQgIGRlZmluZS5hbWRcbiAgICAgICAgZGVmaW5lIFtcInVuZGVyc2NvcmVcIiwgXCJiYWNrYm9uZVwiXSwgKF8sIEJhY2tib25lKS0+XG4gICAgICAgICAgICBnbG9iYWwuQmFja2JvbmUuTGluZWFyX01vZGVsID0gZmFjdG9yeSBfLCBCYWNrYm9uZVxuXG4gICAgZWxzZSBpZiB0eXBlb2YgbW9kdWxlIGlzbnQgXCJ1bmRlZmluZWRcIiAgYW5kICBtb2R1bGUuZXhwb3J0c1xuICAgICAgICBfID0gcmVxdWlyZSBcInVuZGVyc2NvcmVcIlxuICAgICAgICBCYWNrYm9uZSA9IHJlcXVpcmUgXCJiYWNrYm9uZVwiXG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSBfLCBCYWNrYm9uZVxuXG4gICAgZWxzZVxuICAgICAgICBnbG9iYWwuQmFja2JvbmUuTGluZWFyX01vZGVsID0gZmFjdG9yeSBnbG9iYWwuXywgZ2xvYmFsLkJhY2tib25lIl0sInNvdXJjZVJvb3QiOiIvc291cmNlLyJ9